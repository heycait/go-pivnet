// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"github.com/pivotal-cf/go-pivnet/download"
)

type ProxyResponse struct {
	FilenameStub        func() string
	filenameMutex       sync.RWMutex
	filenameArgsForCall []struct{}
	filenameReturns     struct {
		result1 string
	}
	filenameReturnsOnCall map[int]struct {
		result1 string
	}
	SizeStub        func() int64
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct{}
	sizeReturns     struct {
		result1 int64
	}
	sizeReturnsOnCall map[int]struct {
		result1 int64
	}
	RequestStub        func() download.IProxyRequest
	requestMutex       sync.RWMutex
	requestArgsForCall []struct{}
	requestReturns     struct {
		result1 download.IProxyRequest
	}
	requestReturnsOnCall map[int]struct {
		result1 download.IProxyRequest
	}
	ErrStub        func() error
	errMutex       sync.RWMutex
	errArgsForCall []struct{}
	errReturns     struct {
		result1 error
	}
	errReturnsOnCall map[int]struct {
		result1 error
	}
	IsCompleteStub        func() bool
	isCompleteMutex       sync.RWMutex
	isCompleteArgsForCall []struct{}
	isCompleteReturns     struct {
		result1 bool
	}
	isCompleteReturnsOnCall map[int]struct {
		result1 bool
	}
	BytesPerSecondStub        func() float64
	bytesPerSecondMutex       sync.RWMutex
	bytesPerSecondArgsForCall []struct{}
	bytesPerSecondReturns     struct {
		result1 float64
	}
	bytesPerSecondReturnsOnCall map[int]struct {
		result1 float64
	}
	BytesCompleteStub        func() int64
	bytesCompleteMutex       sync.RWMutex
	bytesCompleteArgsForCall []struct{}
	bytesCompleteReturns     struct {
		result1 int64
	}
	bytesCompleteReturnsOnCall map[int]struct {
		result1 int64
	}
	ProgressStub        func() float64
	progressMutex       sync.RWMutex
	progressArgsForCall []struct{}
	progressReturns     struct {
		result1 float64
	}
	progressReturnsOnCall map[int]struct {
		result1 float64
	}
	DoneStub        func()
	doneMutex       sync.RWMutex
	doneArgsForCall []struct{}
	ETAStub         func() time.Time
	eTAMutex        sync.RWMutex
	eTAArgsForCall  []struct{}
	eTAReturns      struct {
		result1 time.Time
	}
	eTAReturnsOnCall map[int]struct {
		result1 time.Time
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ProxyResponse) Filename() string {
	fake.filenameMutex.Lock()
	ret, specificReturn := fake.filenameReturnsOnCall[len(fake.filenameArgsForCall)]
	fake.filenameArgsForCall = append(fake.filenameArgsForCall, struct{}{})
	fake.recordInvocation("Filename", []interface{}{})
	fake.filenameMutex.Unlock()
	if fake.FilenameStub != nil {
		return fake.FilenameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.filenameReturns.result1
}

func (fake *ProxyResponse) FilenameCallCount() int {
	fake.filenameMutex.RLock()
	defer fake.filenameMutex.RUnlock()
	return len(fake.filenameArgsForCall)
}

func (fake *ProxyResponse) FilenameReturns(result1 string) {
	fake.FilenameStub = nil
	fake.filenameReturns = struct {
		result1 string
	}{result1}
}

func (fake *ProxyResponse) FilenameReturnsOnCall(i int, result1 string) {
	fake.FilenameStub = nil
	if fake.filenameReturnsOnCall == nil {
		fake.filenameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.filenameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ProxyResponse) Size() int64 {
	fake.sizeMutex.Lock()
	ret, specificReturn := fake.sizeReturnsOnCall[len(fake.sizeArgsForCall)]
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct{}{})
	fake.recordInvocation("Size", []interface{}{})
	fake.sizeMutex.Unlock()
	if fake.SizeStub != nil {
		return fake.SizeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sizeReturns.result1
}

func (fake *ProxyResponse) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *ProxyResponse) SizeReturns(result1 int64) {
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 int64
	}{result1}
}

func (fake *ProxyResponse) SizeReturnsOnCall(i int, result1 int64) {
	fake.SizeStub = nil
	if fake.sizeReturnsOnCall == nil {
		fake.sizeReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.sizeReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *ProxyResponse) Request() download.IProxyRequest {
	fake.requestMutex.Lock()
	ret, specificReturn := fake.requestReturnsOnCall[len(fake.requestArgsForCall)]
	fake.requestArgsForCall = append(fake.requestArgsForCall, struct{}{})
	fake.recordInvocation("Request", []interface{}{})
	fake.requestMutex.Unlock()
	if fake.RequestStub != nil {
		return fake.RequestStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.requestReturns.result1
}

func (fake *ProxyResponse) RequestCallCount() int {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	return len(fake.requestArgsForCall)
}

func (fake *ProxyResponse) RequestReturns(result1 download.IProxyRequest) {
	fake.RequestStub = nil
	fake.requestReturns = struct {
		result1 download.IProxyRequest
	}{result1}
}

func (fake *ProxyResponse) RequestReturnsOnCall(i int, result1 download.IProxyRequest) {
	fake.RequestStub = nil
	if fake.requestReturnsOnCall == nil {
		fake.requestReturnsOnCall = make(map[int]struct {
			result1 download.IProxyRequest
		})
	}
	fake.requestReturnsOnCall[i] = struct {
		result1 download.IProxyRequest
	}{result1}
}

func (fake *ProxyResponse) Err() error {
	fake.errMutex.Lock()
	ret, specificReturn := fake.errReturnsOnCall[len(fake.errArgsForCall)]
	fake.errArgsForCall = append(fake.errArgsForCall, struct{}{})
	fake.recordInvocation("Err", []interface{}{})
	fake.errMutex.Unlock()
	if fake.ErrStub != nil {
		return fake.ErrStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.errReturns.result1
}

func (fake *ProxyResponse) ErrCallCount() int {
	fake.errMutex.RLock()
	defer fake.errMutex.RUnlock()
	return len(fake.errArgsForCall)
}

func (fake *ProxyResponse) ErrReturns(result1 error) {
	fake.ErrStub = nil
	fake.errReturns = struct {
		result1 error
	}{result1}
}

func (fake *ProxyResponse) ErrReturnsOnCall(i int, result1 error) {
	fake.ErrStub = nil
	if fake.errReturnsOnCall == nil {
		fake.errReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.errReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ProxyResponse) IsComplete() bool {
	fake.isCompleteMutex.Lock()
	ret, specificReturn := fake.isCompleteReturnsOnCall[len(fake.isCompleteArgsForCall)]
	fake.isCompleteArgsForCall = append(fake.isCompleteArgsForCall, struct{}{})
	fake.recordInvocation("IsComplete", []interface{}{})
	fake.isCompleteMutex.Unlock()
	if fake.IsCompleteStub != nil {
		return fake.IsCompleteStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isCompleteReturns.result1
}

func (fake *ProxyResponse) IsCompleteCallCount() int {
	fake.isCompleteMutex.RLock()
	defer fake.isCompleteMutex.RUnlock()
	return len(fake.isCompleteArgsForCall)
}

func (fake *ProxyResponse) IsCompleteReturns(result1 bool) {
	fake.IsCompleteStub = nil
	fake.isCompleteReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ProxyResponse) IsCompleteReturnsOnCall(i int, result1 bool) {
	fake.IsCompleteStub = nil
	if fake.isCompleteReturnsOnCall == nil {
		fake.isCompleteReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isCompleteReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ProxyResponse) BytesPerSecond() float64 {
	fake.bytesPerSecondMutex.Lock()
	ret, specificReturn := fake.bytesPerSecondReturnsOnCall[len(fake.bytesPerSecondArgsForCall)]
	fake.bytesPerSecondArgsForCall = append(fake.bytesPerSecondArgsForCall, struct{}{})
	fake.recordInvocation("BytesPerSecond", []interface{}{})
	fake.bytesPerSecondMutex.Unlock()
	if fake.BytesPerSecondStub != nil {
		return fake.BytesPerSecondStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bytesPerSecondReturns.result1
}

func (fake *ProxyResponse) BytesPerSecondCallCount() int {
	fake.bytesPerSecondMutex.RLock()
	defer fake.bytesPerSecondMutex.RUnlock()
	return len(fake.bytesPerSecondArgsForCall)
}

func (fake *ProxyResponse) BytesPerSecondReturns(result1 float64) {
	fake.BytesPerSecondStub = nil
	fake.bytesPerSecondReturns = struct {
		result1 float64
	}{result1}
}

func (fake *ProxyResponse) BytesPerSecondReturnsOnCall(i int, result1 float64) {
	fake.BytesPerSecondStub = nil
	if fake.bytesPerSecondReturnsOnCall == nil {
		fake.bytesPerSecondReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.bytesPerSecondReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *ProxyResponse) BytesComplete() int64 {
	fake.bytesCompleteMutex.Lock()
	ret, specificReturn := fake.bytesCompleteReturnsOnCall[len(fake.bytesCompleteArgsForCall)]
	fake.bytesCompleteArgsForCall = append(fake.bytesCompleteArgsForCall, struct{}{})
	fake.recordInvocation("BytesComplete", []interface{}{})
	fake.bytesCompleteMutex.Unlock()
	if fake.BytesCompleteStub != nil {
		return fake.BytesCompleteStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bytesCompleteReturns.result1
}

func (fake *ProxyResponse) BytesCompleteCallCount() int {
	fake.bytesCompleteMutex.RLock()
	defer fake.bytesCompleteMutex.RUnlock()
	return len(fake.bytesCompleteArgsForCall)
}

func (fake *ProxyResponse) BytesCompleteReturns(result1 int64) {
	fake.BytesCompleteStub = nil
	fake.bytesCompleteReturns = struct {
		result1 int64
	}{result1}
}

func (fake *ProxyResponse) BytesCompleteReturnsOnCall(i int, result1 int64) {
	fake.BytesCompleteStub = nil
	if fake.bytesCompleteReturnsOnCall == nil {
		fake.bytesCompleteReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.bytesCompleteReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *ProxyResponse) Progress() float64 {
	fake.progressMutex.Lock()
	ret, specificReturn := fake.progressReturnsOnCall[len(fake.progressArgsForCall)]
	fake.progressArgsForCall = append(fake.progressArgsForCall, struct{}{})
	fake.recordInvocation("Progress", []interface{}{})
	fake.progressMutex.Unlock()
	if fake.ProgressStub != nil {
		return fake.ProgressStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.progressReturns.result1
}

func (fake *ProxyResponse) ProgressCallCount() int {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	return len(fake.progressArgsForCall)
}

func (fake *ProxyResponse) ProgressReturns(result1 float64) {
	fake.ProgressStub = nil
	fake.progressReturns = struct {
		result1 float64
	}{result1}
}

func (fake *ProxyResponse) ProgressReturnsOnCall(i int, result1 float64) {
	fake.ProgressStub = nil
	if fake.progressReturnsOnCall == nil {
		fake.progressReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.progressReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *ProxyResponse) Done() {
	fake.doneMutex.Lock()
	fake.doneArgsForCall = append(fake.doneArgsForCall, struct{}{})
	fake.recordInvocation("Done", []interface{}{})
	fake.doneMutex.Unlock()
	if fake.DoneStub != nil {
		fake.DoneStub()
	}
}

func (fake *ProxyResponse) DoneCallCount() int {
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	return len(fake.doneArgsForCall)
}

func (fake *ProxyResponse) ETA() time.Time {
	fake.eTAMutex.Lock()
	ret, specificReturn := fake.eTAReturnsOnCall[len(fake.eTAArgsForCall)]
	fake.eTAArgsForCall = append(fake.eTAArgsForCall, struct{}{})
	fake.recordInvocation("ETA", []interface{}{})
	fake.eTAMutex.Unlock()
	if fake.ETAStub != nil {
		return fake.ETAStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.eTAReturns.result1
}

func (fake *ProxyResponse) ETACallCount() int {
	fake.eTAMutex.RLock()
	defer fake.eTAMutex.RUnlock()
	return len(fake.eTAArgsForCall)
}

func (fake *ProxyResponse) ETAReturns(result1 time.Time) {
	fake.ETAStub = nil
	fake.eTAReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *ProxyResponse) ETAReturnsOnCall(i int, result1 time.Time) {
	fake.ETAStub = nil
	if fake.eTAReturnsOnCall == nil {
		fake.eTAReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.eTAReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *ProxyResponse) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.filenameMutex.RLock()
	defer fake.filenameMutex.RUnlock()
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	fake.errMutex.RLock()
	defer fake.errMutex.RUnlock()
	fake.isCompleteMutex.RLock()
	defer fake.isCompleteMutex.RUnlock()
	fake.bytesPerSecondMutex.RLock()
	defer fake.bytesPerSecondMutex.RUnlock()
	fake.bytesCompleteMutex.RLock()
	defer fake.bytesCompleteMutex.RUnlock()
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	fake.eTAMutex.RLock()
	defer fake.eTAMutex.RUnlock()
	return fake.invocations
}

func (fake *ProxyResponse) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ download.IProxyResponse = new(ProxyResponse)
